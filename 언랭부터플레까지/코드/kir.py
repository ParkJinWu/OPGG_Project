# -*- coding: utf-8 -*-
"""KIR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13w710FR2OqBwHe-7y3upG0uLj3ZWlRkt
"""

import json
import requests
import pandas as pd
import time

class KIR:
  key = ''
  summonerName = ''   #api key와 사용자이름을 저장하는 변수

  def __init__(self, key, summonerName):    #생성자 키와 이름을 받아 저장
    self.key = key
    self.summonerName = summonerName    
   
  def get_result(self):
    gameIds = get_gameIds(self.key,self.summonerName)   #분석대상의 최근 10게임의 게임아이디를 리턴하는 메소드
    gameData = get_gameData(self.key,gameIds)   #10개의 게임아이디를 이용해 10개의 게임데이터를 데이터프레임으로 리턴하는 메소드
    inGameData = get_inGameData(gameData)   #게임데이터안에 있는 개인의 지표가 저장되어 있는 stats컬럼을 데이터프레임으로 리턴하는 메소드

    kill = get_aveKIR(self.summonerName, inGameData)
    ward = get_wardTendancy(self.summonerName, inGameData)

    return (kill+ward)

def get_gameIds(api_key,nick):
  # accountId를 뽑기위해 매개변수로 받아온 닉네임을 사용하여 summoner에 저장
  summoner = "https://kr.api.riotgames.com/lol/summoner/v4/summoners/by-name/" + nick +'?api_key=' + api_key # 입력받은 nick변수의 값에 해당하는 accuount아이디를 추출
  s = requests.get(summoner) # requests의 get을 통해 summoner값을 요청하여 s에 저장

  # 얻은 accountId로 매치리스트 100개를 matchlist에 저장한다
  matchlist = "https://kr.api.riotgames.com//lol/match/v4/matchlists/by-account/" + s.json()['accountId'] +'?queue=420&api_key=' + api_key # queue타입을 420으로 지정하여 솔로랭크 경기만 저장한다
  ml = requests.get(matchlist) # requests의 get을 통해 matchlist값을 요청하여 ml에 저장

  #100개의 매치리스트 중 가장 최근에 플레이 한 10개의 게임을 분석
  matchData = pd.DataFrame(ml.json()) # 받아온 json형태 파일을 데이터프레임으로 바꾼후 matchData에 저장한다 
  matches = pd.DataFrame(dict(matchData['matches'])).T # matchData의 딕셔너리형태의 matches를 데이터프레임으로 변환한다  
  matches = matches['gameId']
  gameIds = []
  for i in range(10): # 반복문을 통해 matches의 데이터를 gameIds에 추가한다.
    gameIds.append(matches[i])

  return gameIds # gameIds를 리턴

def get_gameData(api_key,gameIds):
  gameData = pd.DataFrame() # gameData를 저장할 데이터프레임을 선언한다
  for i in range(len(gameIds)): # 매개변수 gameIds의 크기만큼 반복문을 반복한다
    
    match='https://kr.api.riotgames.com/lol/match/v4/matches/' + str(gameIds[i]) + '?api_key=' + api_key # gameIds값을 통해 matches값을 불러온다 
    r = requests.get(match) # requests의 get을 통해 match값을 요청하여 r에 저장

    if r.status_code == 200: # response가 정상
        pass  # 정상일시 pass

    elif r.status_code == 429: # Rate limit exceeded
        while True: # 429error가 끝날 때까지 무한 루프
            if r.status_code == 429: # Rate limit exceeded

                print('try 10 second wait time')
                time.sleep(10) # 10초간 일시정지

                r = requests.get(match) # requests의 get을 통해 match값을 요청하여 r에 저장
                print(r.status_code) 

            elif r.status_code == 200: # 다시 정상이면 무한루프 중지
                print('recovery api cost') 
                break

    elif r.status_code == 503: # Service unavailable
        print('service available error')

        while True: # status_code가 503일 때  
            if r.status_code == 503 or r.status_code == 429: # Service unavailable , Rate limit exceeded

                print('try 10 second wait time')
                time.sleep(10) # 10초간 일시정지

                r = requests.get(match) # requests의 get을 통해 match값을 요청하여 r에 저장
                print(r.status_code)

            elif r.status_code == 200: # 다시 정상이면 무한루프 중지
                print('recovery api cost')
                break
    elif r.status_code == 403: # Forbidden(api갱신)
        print('you need api renewal')
        print('break')
        break

    # 위의 예외처리 코드를 거쳐서 내려왔을 때 해당 코드가 실행
    game = pd.DataFrame(list(r.json().values()), index=list(r.json().keys())).T
    gameData = pd.concat([gameData,game])    
    #game에 하나의 게임 데이터를 뽑아 gameData에 붙임, 10번 반복해 10개의 게임 데이터를 gameData에 집어 넣음

  return gameData # gameData를 리턴

def get_inGameData(gameData):
  part_list = list(gameData['participants']) #participants컬럼을 list로 변환  
                                             #게임 안의 개인의 지표들을 데이터프레임으로 변환하기위해
  name_list = list(gameData['participantIdentities'])  #participantIdentities컬럼을 list로 변환
                                                       #participants컬럼의 데이터프레임에 sunmmonerName을붙이기위해 
  match_df = pd.DataFrame()     #participants의 요소들을 저장할 데이터프레임
  name_df =  pd.DataFrame()     #participantIdentities의 요소들을 저장할 데이터프레임
  for i in range(len(part_list)):
    for j in range(len(part_list)):   #
        match = pd.DataFrame(list(part_list[i][j].values()),index = list(part_list[i][j].keys())).T
        match_df = match_df.append(match) #match_df에 match를 append해서 데이터프레임을 만듬

        name = pd.DataFrame(list(name_list[i][j].values()),index = list(name_list[i][j].keys())).T
        name_df = name_df.append(name)      
      
  match_df.index = range(len(match_df))   #인덱스를 설정해줌
      
  name1_df = pd.DataFrame(list(name_df['player']))    #name_df의 player컬럼을 데이터프레임으로 저장(player컬럼안에 summonerName존재)
  stats_list = list(match_df['stats'])    #match_df의 stats컬럼을 리스트로 저장(stats컬럼에 인게임에서의 각종 지표 저장되어있음)
  inGameData = pd.DataFrame(stats_list)   #리스트로 바꾼 stats컬럼을 데이터프레임으로 저장 
  inGameData['summonerName'] = name1_df['summonerName'] #inGameData에 summonerName추가 

  return inGameData   

def get_aveKIR(nick,inGameData):    
  i = 0
  index = 0
  KA = []   #킬+어시스트를 저장할 리스트
  isWin = []  #승리여부를 저장할 리스트

  while(i<=99):
    if inGameData['summonerName'][i] == nick:   #입력한 소환사이름과 데이터프레임안의 소환사이름이 일치하면
      index = i;    #index에다 i를 저장
    if i % 10 == 9:   #0~9가 한게임, 10~19가 한게임 이런 형식이므로 i%10 == 9일때
      KA.append(inGameData['kills'][index] + inGameData['assists'][index])    #앞에서 저장한 인덱스의 킬과 어시스트를 더해서 KA리스트에 append
      isWin.append(inGameData['win'][index])    #앞에서 저장한 인덱스에서 승리한 여부 저장(자신의 팀의 전체킬을 구하기위해)
    i+=1

  a = 0
  b = 10    
  i = 0
  j = 0   
  tk = 0    #분석대상의 팀의 전체킬을 저장
  totalKill = []  #저장한 전체킬을 리스트로 저장(총 10판이므로)
  for i in range(len(isWin)):  
    for j in range(a,b):    #한판씩보기위해 a와b의 범위를 조절하여 for문을 돌림 
      if inGameData['win'][j] == isWin[i]:    #분석대상의 팀을 뽑기위해 분석대상의 승리여부와 같은 데이터만을 사용 
        tk += inGameData['kills'][j]    #분석대상의 같은팀의 토탈킬을 저장
    totalKill.append(tk)    #토탈킬을 리스트에 추가
    tk = 0    #토탈킬을 다시 0으로 초기화
    a = b
    b += 10     #a와b의 범위를 조절

  killInvolvementRate = []    #1판당 킬관여율 저장할 리스트

  for i in range(len(totalKill)):
    killInvolvementRate.append(int(KA[i] / totalKill[i] * 100)) #킬관여율 구해서 리스트에 추가

  sum_KIV = 0 #킬관여율의 평균을 구하기위해 
  for i in range(len(killInvolvementRate)):
    sum_KIV += killInvolvementRate[i]   #구한 10판의 킬관여율을 모두 더해줌
      
  ave_KIV = sum_KIV / len(killInvolvementRate)    #더한 킬관여율을 10판으로 나눔
  whole_Ave_KIV = 50.2    #구한 그마200명의 평균 킬관여율의 평균
  print(nick+"님의 평균 킬관여율은 " + str(ave_KIV) + "입니다.")   #분석대상의 평균 킬관여율 출력
  if ave_KIV >= whole_Ave_KIV:    #평균보다 높으면
    return 'A'    #A(Active) 키워드 부여
  else:   #낮으면
    return 'P'    #P(Passive) 키워드 부여
def get_wardTendancy(nick,inGameData): # visionScore를 통해 시야경향을 판단
  
  # 변수 선언
  i = 0 
  vs_res = 0
  wdp_res = 0
  wdk_res = 0
  vs_avg = 0
  wdp_avg = 0
  wdk_avg = 0
  
  visionScore_mean = inGameData['visionScore'].mean() # visionScore_mean에 viosionSocre 컬럼의 평균값을 .mean()을 통해 저장한다
  wdPlaced_mean = inGameData['wardsPlaced'].mean()
  wdKilled_mean = inGameData['wardsKilled'].mean()

  # 반복문을 통해 검색하고자 하는 유저의 visionScore값을 구한다
  while(i <= 99):
    #summonerName
    if inGameData['summonerName'][i] == nick: # 검색하고자하는 nick변수와 일치할 때
      wdp_res += inGameData['wardsPlaced'][i] # wardsPlaced의 값을 wdp_res에 누적하여 더한다
      wdk_res += inGameData['wardsKilled'][i] # wardsKilled 값을 wdk_res에 누적하여 더한다
      vs_res += inGameData['visionScore'][i] # visionScore의 값을 vs_res에 누적하여 더한다

    i += 1

  vs_avg = vs_res / 10 # vs_avg변수에 검색하고자 하는 유저의 visionScore의 평균값을 저장한다
  wdp_avg = wdp_res / 10 # wdp_avg변수에 검색하고자하는 유저의 wardsPlaced의 평균값을 저장한다
  wdk_avg = wdk_res / 10 # wdk_avg변수에 검색하고자하는 유저의 wardsKilled의 평균값을 저장한다
 
  if vs_avg > visionScore_mean:
    print(nick+"님의 평균 시야점수는 " + str(vs_avg) + "입니다.")
    return 'S' # S값을 리턴
  else: # vs_avg가 평균보다 낮을 경우
    if wdp_avg > wdPlaced_mean: # 와드를 잘 설치하거나 와드를 잘지우는 경우도 
      print(nick+"님의 평균 와드설치 개수는 " + str(wdp_avg) + "입니다.")
      return 'S' # S를 리턴한다
    elif wdk_avg > wdKilled_mean:
      print(nick+"님의 평균 와드제거 개수는 " + str(wdk_avg) + "입니다.")
      return 'S'
    else: # 3가지 값이 평균보다 다 낮은 경우
      print(nick+"님의 평균 시야점수는 " + str(vs_avg) + "입니다.")
      print(nick+"님의 평균 와드설치 개수는 " + str(wdp_avg) + "입니다.")
      print(nick+"님의 평균 와드제거 개수는 " + str(wdk_avg) + "입니다.")
      return 'D' # D를 리턴한다
    